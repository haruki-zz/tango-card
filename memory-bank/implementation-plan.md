# 实施计划

1. 初始化开发环境
   - 步骤：确认 Node 版本满足 Electron/Vite 要求，执行依赖安装，配置 `.env.local`，仅包含 OpenAI/Google 密钥占位（空值即可）避免后续读取报错。
   - 结果：项目可在本地安装依赖并具备基础环境变量文件（仅密钥）。
   - 验证：运行 `npm install` 不报错；执行 `npm run lint` 目前仅检查配置是否就绪。

2. 搭建 Electron + React/Vite 基础骨架
   - 步骤：创建 `src/main` 与 `src/renderer` 基础入口，配置 electron-vite 或等效脚手架、`electron-builder` 打包目标，渲染端暂时保留空白页面。
   - 结果：可启动空白窗口的跨平台桌面应用，主/渲染进程热更新可用，为后端功能提供运行容器。
   - 验证：执行 `npm run dev` 启动后看到空白窗口且控制台无报错；执行 `npm run build` 生成产物目录。

3. 配置 ESLint、Prettier（先行保证规范）
   - 步骤：接入 ESLint + Prettier 配置与 scripts，约束 TypeScript 规则；Tailwind 暂缓到 UI 阶段。
   - 结果：代码有统一风格检查，后续开发可即时发现格式问题。
   - 验证：运行 `npm run lint` 确认无格式错误。

4. 定义共享类型与 SM-2 计算
   - 步骤：在 `src/shared` 定义词条（无 `source` 字段）、复习日志、活跃度数据类型与 JSON 校验逻辑；缺失 `sm2` 字段时按默认值自动补全，缺失时间字段按当前时间补全；编写 SM-2 更新与队列排序纯函数。
   - 结果：拥有可复用的纯函数与类型，供主/渲染进程调用，默认补全逻辑明确。
   - 验证：编写 Vitest 单测覆盖 SM-2 更新公式、队列排序、补全逻辑与 JSON 校验的正常与边界输入，运行 `npm test -- shared`。

5. 主进程存储层（文件读写）
   - 步骤：在 `src/main` 实现对 `words.jsonl`、`reviews.jsonl`、`activity.json` 的读写，采用临时文件写入再替换；封装新增词条、记录复习日志、聚合活跃度的函数。缺失 `sm2` 或时间字段时按默认/当前时间补全，不写入 `source`。
   - 结果：可靠的本地数据存储，支持 append 与聚合读取，字段补全一致。
   - 验证：使用 Vitest + 临时目录单测验证写入后文件内容与 JSON 校验/补全一致，模拟磁盘写失败时保证原文件未损坏。

6. 主进程 AI 提供商适配层（优先完成）
   - 步骤：抽象统一接口封装 OpenAI 与 Google 调用，Google 使用官方 Gemini SDK（首选 Gemini Flash 2.5 Lite），严格按官方文档配置请求头、路径与参数，加入合理的默认超时与长度限制，提供 mock 实现供无网络测试；不返回或记录完整密钥。
   - 结果：可通过统一方法生成词条内容，并具备可替换的 provider 结构，确认能正确接收并解析返回字段。
   - 验证：单测用 mock fetch 验证超时/错误分支与字段解析；在 dev 模式下以 mock provider 生成固定响应，确保无密钥时也能走通流程。

7. IPC 合同与安全桥接
   - 步骤：定义类型安全的 IPC 信道，暴露新增词条（含 AI 生成）、加载词库、拉取复习队列、提交评分、读取/写入活跃度、导入/导出、设置 provider 与密钥等接口；通过 `contextBridge` 限定可调用列表。
   - 结果：渲染进程只能调用受控接口，返回值已过校验。
   - 验证：编写主进程集成单测，使用 electron-mock 或直接调用 handler 验证各接口的入参校验与返回格式；确保未知信道无法调用。

8. 后端导入/导出与数据校验
   - 步骤：在主进程实现导入 JSON/JSONL、导出 JSON/CSV 的逻辑，导入时进行 schema 校验与按 `word` 去重；无效记录跳过且报告，合法新记录直接覆盖同词条（含 `sm2` 与 `created_at`）。
   - 结果：数据迁移与校验逻辑完备，等待前端入口接入。
   - 验证：单测覆盖合法/非法文件、重复 `word` 覆盖、无效记录跳过；模拟磁盘文件读写，确认错误分支不会污染现有数据。

9. 渲染进程状态管理（Zustand）
   - 步骤：建立全局 store，包含词库列表、当前复习队列、session 状态、活跃度数据、AI provider 配置；封装调用 IPC 的异步 actions。
   - 结果：前端组件可通过 store 获取数据与触发异步操作，状态与主进程数据同步。
   - 验证：编写 store 单测，mock IPC 层验证 actions 对状态的更新与错误处理路径。

10. 配置 Tailwind 与基础主题
    - 步骤：在 renderer 集成 Tailwind，添加基础浅色/绿色变量与全局样式，确保后续 UI 复用。
    - 结果：前端可使用原子化样式。
    - 验证：运行 `npm run lint` 确认样式文件通过；启动 `npm run dev` 查看全局样式是否生效（可用占位文本）。

11. 新增词条流程（最小可用 UI）
    - 步骤：实现表单输入单词、触发 AI 生成预览、允许用户编辑结果后保存；保存成功刷新词库与活跃度。
    - 结果：用户可新增词条并看到持久化效果。
    - 验证：编写 React Testing Library 测试，mock IPC 返回，验证表单校验、加载/错误提示、保存后列表刷新；手动运行 `npm run dev` 新增词条并检查 `words.jsonl` 写入。

12. 复习队列与 SM-2 更新 UI
   - 步骤：渲染端加载待复习队列，卡片正反面切换，评分后调用 IPC 更新词条与复习日志；仅在用户完成一轮复习时计入 session（无待复习词不计，中途退出/崩溃不计，防止重复计数）。
   - 结果：用户可按照 SM-2 流程复习并更新下一次时间，活跃度 session 计数准确增加。
    - 验证：组件测试覆盖翻转与评分按钮行为，断言调用的 IPC 参数；单测验证 SM-2 更新后 `next_review_at` 合法；手动复习一次后检查 `reviews.jsonl` 与 `activity.json`。

13. 活跃度方格视图
    - 步骤：实现按日展示新增词数与 session 数的绿色深浅方格，hover 展示详情。
    - 结果：用户可视化每日活跃度。
    - 验证：组件测试使用固定数据渲染颜色深浅与 tooltip 文案；手动新增/复习后查看 UI 变化。

14. 前端导入/导出与错误提示
    - 步骤：在 UI 提供导入 JSON/JSONL、导出 JSON/CSV 入口，展示进度与错误提示，对接主进程校验结果。
    - 结果：用户可安全迁移数据，损坏文件被拒绝。
    - 验证：组件测试覆盖合法/非法文件流程、重复 ID 提示；手动导入/导出小样本文件并在磁盘检查内容。

15. 设置页（LLM 提供商与密钥）
    - 步骤：提供 provider 下拉与密钥输入，主进程使用系统安全存储保存密钥，不回显完整值；增加测试用 mock provider 选项。
    - 结果：用户可切换模型并安全存储密钥，默认不泄露。
    - 验证：组件测试验证表单校验与 IPC 调用；手动切换 provider、重启应用后检查设置持久化。

16. 打包与发布烟测
    - 步骤：配置 `electron-builder` 目标（macOS dmg/zip、Windows nsis/portable），校验静态资源与环境变量注入；生成安装包做最小功能回归。
    - 结果：可分发的安装包，基础功能正常。
    - 验证：运行 `npm run build` 与 `npm run pack`，在本地安装包内完成新增词条、复习、活跃度查看的手动测试。

17. 回归测试与文档补充
    - 步骤：整理新增测试覆盖率报告，补充 README/用户指引，若有架构调整同步更新设计文档与架构说明。
    - 结果：测试覆盖核心路径，文档同步，团队可交接。
    - 验证：执行 `npm test -- --coverage` 达到预期阈值；人工审阅文档与设计文件更新完备。
